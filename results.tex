Our goal is to understand how JavaScripts projects evolves. First we want to analyze the growth of JavaScript projects. Second, the time to release new versions and how frequently the functions in JavaScript changes. Third, how actively developers from the open source community collaborates to the projects and what is the average time to fix a bug in these projects. Fourth, How common is it to have bad practices and anti-patterns in JavaScript projects. In order to do that we use the collected data from 15 open source projects as described in our approach to answer our research questions. 

\vspace{3 mm}
\noindent{\rqi}
\vspace{3 mm}

\noindent{\textbf{Motivation:}} Growth is an important aspect of evolution. Even more to open source projects. Growth can mean that the project is in use, that it is changing over time and that it may be adapting to the needs of users. However, it is important to understand how this growing is happening. If a project grows without any planning or if it is becoming too complex that users and developers abandon it. In this case growth is a bad sign. Therefore we conduct our study to understand if the projects are growing in a maintainable manner and if the developers are building the software to the future.   

\vspace{1 mm}
\noindent{\textbf{Approach:}} First we measure the lines of code, number of commented lines, the number of directories, the number of functions, statements and complexity for each release of each one of our projects. With the results we plot a graph to analyze the growth distribution of our select metrics and draw conclusions. 

\vspace{1 mm}
\noindent{\textbf{Results:}} Table \ref{tab:evolution_overview} shows the difference each project has in terms of metrics in comparison of first and last release.
As we can observe Brackets' first release contains 6271 lines of code but it ends up with 266801 lines of code in the last release. Bracket's last release is the most biggest evolved project with in four years of its existence. It started with 14 directories while in the last release it contains 179 directories. Brackets has 60 releases during its lifetime with 15871 commits. On the other hand NPM with 298 releases is the project with most releases in our dataset. It starts with 1979 lines of code where the last release exceeds to 19837 lines of code with 2231 functions added since the first release.
\todo{create plot to put here}

\begin{table*}[!hbt]
	\begin{center}
		\caption{Release details from each analyzed project}
		\label{tab:evolution_overview}
		\begin{tabular}{l l| c c c c c c}
			\toprule
			\textbf{Project}  & \textbf{Release} & \textbf{LOC} & \textbf{Commented lines} & \textbf{Directories} & \textbf{Functions} & \textbf{Statements} & \textbf{Complexity}\\ \midrule              
			\multirow{2}*{Coffeescript}& First  0.6.1                   &           4693 &           836 &           3 &       915 &       5916 &       2958\\
			& Last   1.9.0                   &           7723 &           124 &           6 &      1262 &       6687 &       5251\\ \midrule
			\multirow{2}*{Less.js     }& First  v1.0                    &           1269 &           279 &           6 &       179 &        818 &        634\\
			& Last   v2.3.1                  &          18585 &          2085 &          18 &      2605 &      13609 &       9414\\ \midrule
			\multirow{2}*{Npm         }& First  v0.0.7                  &           1979 &           259 &           3 &       238 &       1234 &        780\\
			& Last   v2.7.4                  &          19837 &          1060 &          34 &      2469 &      12004 &       5918\\ \midrule
			\multirow{2}*{Mongoose    }& First  0.0.1                   &            554 &            12 &           6 &       100 &        373 &        217\\
			& Last   4.0.1                   &          41844 &          5710 &          12 &      5749 &      27722 &       9373\\ \midrule
			\multirow{2}*{Underscore  }& First  1.0.3                   &           1127 &           154 &           2 &       376 &       1317 &        738\\
			& Last   1.8.0                   &           3918 &           385 &           2 &       849 &       3719 &       1650\\ \midrule
			\multirow{2}*{Node-mysql  }& First  v0.1.0                  &           2431 &            55 &           4 &       203 &       1876 &        435\\
			& Last   v2.6.0                  &          10701 &           430 &          16 &      1046 &       8044 &       2010\\ \midrule
			\multirow{2}*{Q           }& First  v0.1.0                  &            188 &            95 &           1 &        35 &        113 &         64\\
			& Last   v1.1.2                  &           6670 &          1149 &           6 &      1396 &       4118 &       2182\\ \midrule
			\multirow{2}*{Request     }& First  v1.2.0                  &            312 &            12 &           2 &        24 &        214 &        112\\
			& Last   v2.54.0                 &           7839 &           333 &           5 &       958 &       4086 &       1713\\ \midrule
			\multirow{2}*{Ember.js    }& First  sc-v2.0.beta.1          &          28582 &         10006 &          67 &      3879 &      21402 &       9743\\
			& Last   v1.11.0-beta.5          &          65548 &         14698 &         115 &      9323 &      38894 &      13878\\ \midrule
			\multirow{2}*{Source-map  }& First  0.1.0                   &           1214 &           855 &           5 &       124 &        669 &        271\\
			& Last   0.4.1                   &           4485 &           791 &           7 &       322 &       2362 &        757\\ \midrule
			\multirow{2}*{Bootstrap   }& First  v1.3.0                  &            886 &           105 &           2 &       130 &        510 &        261\\
			& Last   v3.3.2                  &           6834 &           358 &           5 &       980 &       4532 &       2337\\ \midrule
			\multirow{2}*{Mocha       }& First  0.0.1-alpha1            &           1185 &           284 &           6 &       226 &        703 &        309\\
			& Last   2.2.0                   &           9931 &          2229 &          21 &      1750 &       6586 &       3197\\ \midrule
			\multirow{2}*{Brackets    }& First  sprint-1                &           6271 &          1198 &          14 &      1305 &       4234 &       2183\\
			& Last   release-1.2-prerelease1 &         266801 &         63923 &         179 &     27845 &     148274 &      82848\\ \midrule
			\multirow{2}*{Bower       }& First  v0.1.1                  &           1149 &           117 &           9 &       212 &        856 &        423\\
			& Last   v1.4.0                  &          15802 &          1439 &          17 &      2454 &       8641 &       3646\\ \midrule
			\multirow{2}*{Grunt       }& First  v0.4.0                  &           3972 &           682 &          11 &       492 &       2482 &        886\\
			& Last   v0.4.4                  &           4010 &           663 &          12 &       498 &       2447 &        874\\ \bottomrule
		\end{tabular}
	\end{center}
\end{table*}

\vspace{3 mm}
\noindent{\rqii}
\vspace{3 mm}

\noindent{\textbf{Motivation:}} It is common to use entire JavaScript libraries inside JavaScript projects, and changes in these libraries can impact your project. Therefore, it is important to understand how often new releases are shipped so you can plan ahead how to use or upgrade these libraries. In the same way, understanding how often third party APIs changes can shape the way you utilize them in your project. 

\vspace{1 mm}
\noindent{\textbf{Approach:}} First, we calculate the average number of releases. We count the number of all versions released and divide it by the number of months between the first release and the last release of each project. Second, we analyze the distribution of the releases. We group the releases in intervals of three months each, and we plot the results to interpret the graph. Third, we use function density to explain the state of public API over time. We calculate the function density in intervals of three months for each project. Then we plot the results for analysis. The formula to calculate function density is the following:

\begin{center}
	$Function Density=  \frac{\left ( \frac{Number Of Functions}{Lines Of Code} \right)}{Number Of Releases}\ast 100$
\end{center}

\vspace{1 mm}
\noindent{\textbf{Results:}} We present the average of number of releases in table \ref{tab:average_release} in general JavaScript projects has a fast passed development with a high number of releases. Npm is the project with the highest average of releases per month 5.13, and the lowest average belongs to Grunt 0.41. 

We present how the releases are distribute in figure \ref{fig:release_density}. Based on the results we find that Mongoose has a higher concentration of releases in the beginning of its development (2012) reaching the peak of 24 releases in three months. Later in its life-cycle (2014) the number of releases drops to 4 and currently (2015) the number of releases increased to 10. We can infer that in the beginning of development more releases are necessary due to the number of changes and the immaturity of the project. Bootstrap in the other hand shows lower variation in the number of releases over time. In general is not possible to say that the distribution of the releases are evenly distributed over time. 

\todo{review}
We depict the function density of the five chosen projects that we found more interesting because of which shows different trends. We calculated the function density during time periods of three months.
Figure \ref{fig:function_density} indicates evolution of our five selected projects. Mongoose starts at 2010 with almost 17\% function density and it has faced a decreasing trend during then. It indicates that after a while developers decided to refactor code to have  excessive use of functions removed. Moreover this project from mid 2012 to 2015 shows interesting phenomena. The function density keeps constant rate, but due to the nature of Mongoose project which is a object modeling library for MongoDB there were no any changes in their APIs after stability. Generally, APIs exposed by function declarations and function expressions in JavaScript. As a result the API keeps unchanged for a long period. 

\par
Like Mongoose we have the same trend for Brackets which after a dramatic decline during 2012 to 2013 the function density becomes unchanged for two years. These trends, again revealed the fact that projects become mature and established and they do not need to change their APIs while they are stable. One might argue these project would be stop developing and the behavior is because they are in maintenance phase or they are becoming legacy software. But We have numerous release followed which we cannot say these projects are abandoned.  

\begin{table}[!hbt]
    \begin{center}
        \caption{Average releases per month}
        \label{tab:average_release}
        \begin{tabular}{l| c c c}
           \toprule
           \textbf{Project} & \textbf{Age in months} & \textbf{\# of releases} & \textbf{Average}\\ \midrule
           Npm          &    58 &  298 &   5.13 \\ 
           Mongoose     &    58 &  197 &   3.39 \\
           Bower        &    30 &   65 &   2.16 \\
           Mocha        &    39 &   80 &   2.05 \\
           Ember.js     &    44 &   87 &   1.97 \\
           Brackets     &    37 &   60 &   1.62 \\
           Q            &    50 &   48 &   0.96 \\
           Source-map   &    41 &   29 &   0.70 \\
           Node-mysql   &    55 &   38 &   0.69 \\
           Bootstrap    &    40 &   27 &   0.67 \\
           Less.js      &    57 &   38 &  0.66 \\
           Request      &    49 &   32 &  0.65 \\
           Coffeescript &    57 &   31 &  0.54 \\
           Underscore   &    56 &   30 &  0.53 \\
           Grunt        &    12 &    5 &  0.41 \\ \bottomrule
      \end{tabular}
    \end{center}
\end{table}

% commented formula
% \begin{center}
% 	$Release Density= \frac{\sum Releases}{3 Months}$
% \end{center}

% release density 
\begin{figure}[thb!]
	\caption{Release density evolution}
	\label{fig:release_density}
	\includegraphics[width=90mm,scale=0.5]{figures/release_density}
	\includegraphics[width=90mm,scale=0.5]{figures/release_density_2}
	\includegraphics[width=90mm,scale=0.5]{figures/release_density_3}
\end{figure}

% Function density 
 \begin{figure}[thb!]
 	\caption{Function density evolution}
 	\label{fig:function_density}
 	\includegraphics[width=90mm,scale=0.5]{figures/function_density}
 	\includegraphics[width=90mm,scale=0.5]{figures/function_density_2}
 	\includegraphics[width=90mm,scale=0.5]{figures/function_density_3}
 \end{figure}

\vspace{3 mm}
\noindent{\rqiii}
\vspace{3 mm}

\par For number of developers we tried to gather data based on email of authors that commit code, however we found out that authors can have multiple emails register to one login id. To overcome this problem we tried to count the number of developers based on the Github usernames. 

\par
Having comments as one of the artifacts that can be a sign of improvement in the readability of source code we examined it as metric of evolution.
Brackets has the most comment lines with having 63923 comment lines followed by Ember.js with 14698 comment lines. The less documented project is CoffeeScript with having only 124 lines of documentation. What makes the result interesting, is the fact that CoffeeScript starts with 836 lines of comments in the first release but in the last release we have only 124 lines of code. CoffeeScript and Grunt are the only projects that adapt this pattern, while all the other projects show growing trend in number of comments during evolution.  

The next characteristics we measure in evolution is to measure how much a project is community driven. We count number of developers having at least one commit in each period between releases. Figure \ref{fig:number_of_developers} show the number of developers in different time slots. Request and Bootstrap are among projects with over 80 and 100 developers in specific peaks. Despite the fact that Underscore has fluctuated so much, at recent releases it shows that it gains some more attention and it becomes more community driven in terms of number of volunteer contributors. Project \textit{q} takes less attention as compare to other projects. It has never had more than 20 developers since its beginning in mid 2010.
\par
Request project had one drastic fell down in mid 2013. By exploring in more details, we found that they have two releases which are closed to each other. The first one has more than 80 developers while the other has less 10 developers. This indicates they found some major issues in former release and few core developers instantly fix them and another release followed by previous one. One interesting phenomena that we observe is the number of released skewed to the right of each graph. Best practices in software engineering suggest having iterative and incremental development and we found out developers tend to have more smaller release in time rather than having one huge release every 6 months.  

% developers per release 
\begin{figure}[thb!]
	\caption{Number of developers per release}
	\label{fig:number_of_developers}
	\includegraphics[width=90mm,scale=0.5]{figures/number_of_developers}
	\includegraphics[width=90mm,scale=0.5]{figures/number_of_developers_2}
	\includegraphics[width=90mm,scale=0.5]{figures/number_of_developers_3}
\end{figure}


\ref{fig:number_of_issues}
Having a software without bug means that software is never used by users. When it comes to bugs, we can find where and in what extent the software's problem are saturated. The module or component with more issues is an indication of complex. Taking a look in each project and density of issues during releases get us an insight into on how quality JavaScript projects are developed. Figure \ref{fig:number_of_issues} shows numbers of issues introduced between releases.

\begin{figure}[thb!]
	\caption{Number of issues introduced in each release}
	\label{fig:number_of_issues}
	\includegraphics[width=90mm,scale=0.5]{figures/issues_per_release}
	\includegraphics[width=90mm,scale=0.5]{figures/issues_per_release_2}
	\includegraphics[width=90mm,scale=0.5]{figures/issues_per_release_3}
\end{figure}

 Figure \ref{fig:avg_issue_fix} shows the average time it takes to get project fixed in all JavaScript projects.
 
\begin{figure}[thb!]
	\caption{Average time to fix issues}
	\label{fig:avg_issue_fix}
	\includegraphics[width=90mm,scale=0.5]{figures/average_days_to_fix_bugs}

\end{figure}


Figure \ref{fig:number_of_issues} shows Bootstrap in special releases had around 1000 issues caught by testers and developers. Looking back to the nature of this project, it is obvious such a huge library which provides lots of functionalities would probably have numerous users whom they can report bugs. Moreover for the release in the mid of 2013 we can see the distance between the release and previous ones was significant. By looking at the data we found out that release was one of the major releases that Bootstrap had before. 

\begin{table}[!hbt]
	\begin{center}
		\caption{Average time to fix a bug}
		\label{tab:average_time_bugfix}
		\begin{tabular}{l| c }
			\toprule
			\textbf{Project}  & \textbf{Average bug fix in days} \\ \midrule              
			Coffeescript    & 46  \\
			Less.js         & 113 \\
			Npm             & 58  \\
			Mongoose        & 44  \\
			Underscore      & 14  \\
			Node-mysql      & 47  \\
			Q               & 30  \\
			Request         & 105 \\
			Ember.js        & 22  \\
			Source-map      & 17  \\
			Bootstrap       & 11  \\
			Mocha           & 83  \\
			Brackets        & 26  \\
			Bower           & 30  \\
			Grunt           & 28  \\  \bottomrule
		\end{tabular}
	\end{center}
\end{table}

To study more about these different projects we conduct another analysis to find the average time it takes to fix a bug that reported after releases. We use Github issue tracker to extract all information related to bugs and then we grouped them by releases. Then the average time it takes since the bug was created to the date it has closed is calculated. Table \ref{tab:average_time_bugfix} shows the result that the average time in days that it takes to fix bugs in each of selected projects.  
\par 
What interesting fact we found is that Bootstrap has the least number of days taken to fix a bug. Considering number of developers Bootstrap has based on Figure \ref{fig:number_of_developers} we found that this project has one of the most active communities among other projects. While Less.js is a project that on average it takes 113 days to get a bug fixed with fewer developers. 
\par
\textit{Underscore} has a good response and fixed rate among projects. While we are comparing the rate of bug fixing, we observe that Underscore is also one of the projects that has large number of developers contributing to the project. By having deeper observation into the data, we found out that number of developers are positively correlated to the time it takes to fix and close a bug.

\par For project \textit{q} it takes on average 30 days to fix bugs. By looking at number of developers we found out it has comparably less developers as compare to other projects but we have to take into account the fact of projects size and scale are in different order. A project that has fewer functionality might has fewer bugs and as a consequence less time would it take to fix a bug.

\vspace{5 mm}
\noindent{\rqiv}
\vspace{5 mm}

\subsection{JavaScript Rule violations}
We use SonarQube to use its various rules for finding code smells in JavaScript projects. Utilizing SonarQube give us the ability to extract code smells with different severity. To explain it more we list following rules as an example for issues with different severity:

	\begin{table*}[!hbt]
		\begin{center}
			\caption{Bad smells breakdown from each analyzed project}
			\label{tab:bad_smell_evolution_overview}
			\begin{tabular}{l l| c c c c c }
				\toprule
				\textbf{Project}  & \textbf{Release} & \textbf{Blocker smells} & \textbf{Critical smells} & \textbf{Major smells} & \textbf{Minor smells} & \textbf{Info smells} \\ \midrule              
				\multirow{2}*{Coffeescript}& First  0.6.1                   &           0 &           2 &          1692 &       31 &        0 \\
				& Last   1.9.0                   &           0 &           0 &          3528 &       48 &        0 \\ \midrule
				\multirow{2}*{Less.js     }& First  v1.0                    &           0 &           0 &           336 &       24 &        0 \\
				& Last   v2.3.1                  &           3 &           0 &          4285 &      317 &       26 \\ \midrule
				\multirow{2}*{Npm         }& First  v0.0.7                  &           0 &          34 &          1300 &       10 &       11 \\
				& Last   v2.7.4                  &           0 &          18 &         12535 &       49 &        8 \\ \midrule
				\multirow{2}*{Mongoose    }& First  0.0.1                   &           1 &           1 &           316 &        4 &        0 \\
				& Last   4.0.1                   &          22 &          12 &          4773 &      161 &        8 \\ \midrule
				\multirow{2}*{Underscore  }& First  1.0.3                   &           0 &           0 &           465 &       10 &        0 \\
				& Last   1.8.0                   &           1 &           0 &          1000 &       19 &        0 \\ \midrule
				\multirow{2}*{Node-mysql  }& First  v0.1.0                  &           2 &           0 &           230 &       10 &        2 \\
				& Last   v2.6.0                  &          27 &           2 &           479 &       72 &        4 \\ \midrule
				\multirow{2}*{Q           }& First  v0.1.0                  &           0 &           0 &            15 &        1 &        1 \\
				& Last   v1.1.2                  &           0 &           1 &           319 &       41 &       18 \\ \midrule
				\multirow{2}*{Request     }& First  v1.2.0                  &           0 &           0 &           115 &        2 &        0 \\
				& Last   v2.54.0                 &           0 &           0 &          3798 &       20 &       71 \\ \midrule
				\multirow{2}*{Ember.js    }& First  sc-v2.0.beta.1          &           0 &           1 &          8469 &      586 &       24 \\
				& Last   v1.11.0-beta.5          &           0 &           0 &          1489 &      343 &       62 \\ \midrule
				\multirow{2}*{Source-map  }& First  0.1.0                   &           1 &           1 &            91 &        5 &        1 \\
				& Last   0.4.1                   &           6 &           1 &           268 &        7 &        1 \\ \midrule
				\multirow{2}*{Bootstrap   }& First  v1.3.0                  &           0 &           0 &           523 &        7 &        0 \\
				& Last   v3.3.2                  &           0 &           0 &          4777 &       49 &       55 \\ \midrule
				\multirow{2}*{Mocha       }& First  0.0.1-alpha1            &           0 &           0 &           233 &        2 &        2 \\
				& Last   2.2.0                   &           0 &           0 &          1675 &       76 &       10 \\ \midrule
				\multirow{2}*{Brackets    }& First  sprint-1                &           0 &          12 &          1167 &       35 &       70 \\
				& Last   release-1.2-prerelease1 &           2 &           3 &         40985 &     5248 &     1879 \\ \midrule
				\multirow{2}*{Bower       }& First  v0.1.1                  &           0 &           0 &           169 &        1 &        0 \\
				& Last   v1.4.0                  &           7 &         117 &           226 &       44 &       18 \\ \midrule
				\multirow{2}*{Grunt       }& First  v0.4.0                  &         123 &           0 &           137 &       11 &       28 \\
				& Last   v0.4.4                  &         142 &           0 &           155 &       10 &       26 \\ \bottomrule
			\end{tabular}
		\end{center}
	\end{table*}

\begin{itemize}
	\item \textbf{"===" and "!=="}:
The == and != operators do type coercion before comparing values. This is bad because it can mask type errors. For example, it evaluates \escape{t} \escape{r} \escape{n} == 0 as true.

It is best to always use the side-effect-less === and !== operators instead. This issue is considered as \textit{Major} issue.

		\begin{lstlisting}[caption=Noncompliant Code Example]
		if (var == 'howdy') {...} // Noncompliant
		\end{lstlisting}
		
		\begin{lstlisting}[caption=Compliant Solution]
		if (var === 'howdy') {...}
		\end{lstlisting}


	\item \textbf{\textit{continue} should not be used}
	continue is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured control flow statements such as if should be used instead. We considered this issue as \textit{Critical} issue.
	
		
		\begin{lstlisting}[caption=Noncompliant Code Example]
		for (i = 0; i < 10; i++) {
		if (i == 5) {
		continue;  /* Non-Compliant */
		}
		alert("i = " + i);
		}
		\end{lstlisting}
		
		\begin{lstlisting}[caption=Compliant Solution]
		for (i = 0; i < 10; i++) {
		if (i != 5) {  /* Compliant */
		alert("i = " + i);
		}
		}
		\end{lstlisting}
	
	
	
	
	\item \textbf{ \textit{switch} statements should end with a \textit{default} clause}
	he requirement for a final default clause is defensive programming. The clause should either take appropriate action or contain a suitable comment as to why no action is taken. It is a \textit{Major} issue.
	

		
		\begin{lstlisting}[caption=Noncompliant Code Example]
		switch (param) {  //missing default clause
		case 0:
		 doSomething();
		break;
		case 1:
		 doSomethingElse();
		 break;
		}
		
		switch (param) {
		 default: // default clause should be the last one
		 error();
		 break;
		case 0:
		 doSomething();
		 break;
		case 1:
		 doSomethingElse();
		 break;
		}
		\end{lstlisting}
		
		\begin{lstlisting}[caption=Compliant Solution]
		switch (param) {
		case 0:
		 doSomething();
		 break;
		case 1:
		 doSomethingElse();
		 break;
		default:
		 error();
		 break;
		}
		\end{lstlisting}	
	
	
	\item \textbf{\textit{with} statements should not be used}
	The use of the with keyword produces an error in JavaScript strict mode code. However, that is not the worst that can be said against with.
	
	Using with allows a short-hand access to an object's properties - assuming they are already set. But use with to access some property not already set in the object, and suddenly you are catapulted out of the object scope and into the global scope, creating or overwriting variables there. Since the effects of with are entirely dependent on the object passed to it, with can be dangerously unpredictable, and should never be used. It is a major issue.
	
		\begin{lstlisting}[caption=Noncompliant Code Example]
	var x = 'a';
	
	var foo = {
		y: 1
	}
	
	with (foo) {  // Noncompliant
		y = 4;  // updates foo.x
		x = 3;  // does NOT add a foo.x property; updates x var in outer scope
	}
	print(foo.x + " " + x); // shows: undefined 3
		\end{lstlisting}
		
			\begin{lstlisting}[caption=Compliant Solution]
			var x = 'a';
			
			var foo = {
			 y: 1
			}
			foo.y = 4;
			foo.x = 3;
			
			print(foo.x + " " + x); // shows: 3 a
			\end{lstlisting}
			
		
	\item \textbf{Statements should be on separate lines}
	For better readability, do not put more than one statement on a single line. It is a minor issue.
	
	\begin{lstlisting}[caption=Noncompliant Code Example]
	if(someCondition) doSomething();
	\end{lstlisting}
	
	\begin{lstlisting}[caption=Compliant Solution]
if(someCondition) {
doSomething();
}
	\end{lstlisting}
	
	

\end{itemize}


Table \ref{tab:bad_smell_evolution_overview} shows the evolution of bad smells with different severities. Most of projects has no or few Blocker smells.  Except project \textit{Grunt} we observed that all project start with zero or less than two blocker bugs. Project \textit{node-mysql} starts with 2 blocker issues and it had 27 in the last release. The weight of Major smells revealed that lacking of a good static code checker and compiler let developers to have more and more rule violations with our any warning from absent compiler in JavaScript. Although JavaScript developers use source code inspection tools such as \textit{JSLint} and \textit{JSHint} we still see rule violation in such a huge extent as compare to Java projects. Statically typed languages such as Java would not let developer to have piece of code that violates type casting rules or having an undeclared variable.
	
	
	