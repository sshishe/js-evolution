Kyriakakis \emph{et al.} \cite{Kyriakakis2014ICMSE} Analyzed the evolution of PHP projects over time. Their work contributes to the evolution scenario because script languages as PHP are often labeled as inappropriate for big projects, under the claim that these languages are not maintainable. During their experiment they analyzed the evolution of five open source projects with a long development history. They analyzed the amount of unused code, the removal of functions, the use of libraries, the stability of the interfaces, the migration to object-orientation and the evolution of complexity. Based on their results they concluded that these projects are submitted to organized changes and perfective maintenance does stills takes place in the projects. They also find that all the projects are gradually migrating to object-orientation fact that indicates planed maintenance as this feature was added in the language after the start of the development of all projects. 

Similarly to this work we pretend to understand how the JavaScript language evolves over time, collaborating with the script languages evolution landscape. In addition to that, we search for possible applications of lessons learned analyzing the evolution of static languages as Java. Finding similar evolution patterns between script and static languages will lead us to best practices that can be applied in both contexts. 

Godfrey \emph{et al.} \cite{Godfrey2000ICMS} analyzed how large open source projects would evolve over time. Until their research, most work in software evolution was related with ``in home'' solutions. They collected and analyzed 6 years of development data from Linux kernel a large open source project with over two million of lines of code in the latest version analyzed at the time. They measured the length of the each full distribution, the lines of code (considering commented and blanks lines and then ignoring them as well), the number of global functions, variables and macros. They found that Linux kernel growth has been super-linear despite the fact of its large size, the collaboration of several volunteers developers that are scattered around the world and that previous research in the area had found that growth of large software systems tends to slow down as the system becomes larger. They also found several important facts particular to the Linux Kernel system as although the source tree for Linux is rather large more than half of the code belongs to devices drivers. 

Xie \emph{et al.} \cite{Xie2009ICSM} also analyses the evolution of open source projects. As there are controversial statements about the evolution of open source projects they decided to conduct their work analyzing first, how Lehman's eight laws of software evolution \cite{Lehman1997METRICS} can be applied in open source projects. Second, they analyze the growth rate of the development and maintenance branches and the distribution of software changes. To conduct this research, they collected historical development data from 7 open source projects, a total of 653 official releases and over 69 years of cumulative program evolution. They found that the first four of the Lehman's laws - Continuing Change, Increasing Complexity, Self Regulation and Continuing Growth - are still applicable in open source software, whereas the other four - Conservation of Organizational Stability, Conservation of Familiarity, Declining Quality and Feedback System - were not possible to validate because of inconclusive results. In addition to that they found that the development branch and the maintenance branch evolves in parallel and that a high percentage of changes are concentrated to a small percentage of code.    

Like these previous works we analyze the evolution of open source projects, but in particular we focus our analyzes in several small to mid-sized open sources projects written in two different languages, one dynamic (JavaScript) and the other one static (Java). We conduct an empirical study to analyze two main factors, first how JavaScript projects evolves over time and second, what are the lessons from static languages that can be applied as a good practice in JavaScript.
 